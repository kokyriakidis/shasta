#pragma once

/*******************************************************************************

In a PrimaryGraph, each vertex represents a primary edge of the marker graph.
Edges are generated by following the reads.

*******************************************************************************/

// Shasta.
#include "Base.hpp"
#include "MarkerGraphEdgePairInfo.hpp"
#include "MultithreadedObject.hpp"
#include "ReadId.hpp"
#include "shastaTypes.hpp"

// Boost libraries.
#include <boost/graph/adjacency_list.hpp>

// Standard library.
#include "iosfwd.hpp"
#include "memory.hpp"
#include "string.hpp"
#include "utility.hpp"
#include "vector.hpp"

namespace shasta {
    class Assembler;
    class MarkerGraph;
    namespace mode3 {

        // The global path graph.
        // Each vertex corresponds to a primary marker graph edge.
        class GlobalPathGraph;
        class GlobalPathGraphVertex;
        class GlobalPathGraphEdge;

        // A subset of the GlobalPathGraph, for example
        // a single connected component, represented as a Boost graph.
        class PrimaryGraphVertex;
        class PrimaryGraphEdge;
        class PrimaryGraph;
        using PrimaryGraphBaseClass = boost::adjacency_list<
            boost::listS,
            boost::vecS,
            boost::bidirectionalS,
            PrimaryGraphVertex,
            PrimaryGraphEdge>;

        class GlobalPathGraphDisplayOptions;

    }
}



// Class to control Graphviz output of GlobalPathGraph and PathGraph.
class shasta::mode3::GlobalPathGraphDisplayOptions {
public:
    bool labels = true;
    bool tooltips = true;
    bool colorVertices = true;
    bool colorEdges = true;
    bool showNonTransitiveReductionEdges = true;

    // Thresholds for coloring by corrected Jaccard similarity J'.
    // If J' <= redJ, the edge is drawn red.
    // If J' >= greenJ, the edge is drawn green.
    // For values in between, the color is interpolated.
    double redJ;
    double greenJ;

    GlobalPathGraphDisplayOptions(double redJ = 0., double greenJ = 1.) :
        redJ(redJ), greenJ(greenJ) {}

    void makeCompact()
    {
        labels = false;
        tooltips = false;
        colorVertices = false;
        colorEdges = false;
    }
};



class shasta::mode3::PrimaryGraphVertex {
public:

    // The corresponding marker graph edgeId.
    MarkerGraphEdgeId edgeId;
};



class shasta::mode3::PrimaryGraphEdge {
public:
    MarkerGraphEdgePairInfo info;
    uint64_t coverage;
    bool isNonTransitiveReductionEdge = false;
};



class shasta::mode3::PrimaryGraph : public PrimaryGraphBaseClass {
public:

    std::map<MarkerGraphEdgeId, vertex_descriptor> vertexMap;
    void addVertex(MarkerGraphEdgeId);

    void addEdge(
        MarkerGraphEdgeId,
        MarkerGraphEdgeId,
        const MarkerGraphEdgePairInfo&,
        uint64_t coverage);

    void writeGraphviz(
        const string& name,
        const GlobalPathGraphDisplayOptions&,
        const MarkerGraph&) const;

    void writeEdgeCoverageHistogram(const string& fileName) const;

    // Create the connected components of this PrimaryGraph,
    // without changing the PrimaryGraph itself.
    vector< shared_ptr<PrimaryGraph> > createConnectedComponents(uint64_t minComponentSize) const;

    void localTransitiveReduction(
        uint64_t distance,
        uint64_t maxCoverage);

    // Remove cross-edges.
    // This removes an edge v0->v1 if the following are all true:
    // - Its coverage is at most lowCoverageThreshold.
    // - Its estimated offset is at least minOffset.
    // - v0 has at least one out-edge with coverage at least highCoverageThreshold.
    // - v1 has at least one in-edge with coverage at least highCoverageThreshold.
    void removeCrossEdges(
        uint64_t lowCoverageThreshold,
        uint64_t highCoverageThreshold,
        uint64_t minOffset);

    // Remove edges for which loss = (commonCount - coverage) / commonCount > maxLoss
    void removeWeakEdges(double maxLoss);

};



class shasta::mode3::GlobalPathGraphVertex {
public:
    MarkerGraphEdgeId edgeId;

    GlobalPathGraphVertex(MarkerGraphEdgeId edgeId) : edgeId(edgeId) {}

    // Compare by edgeId only.
    bool operator<(const GlobalPathGraphVertex& that) const
    {
        return edgeId < that.edgeId;
    }
};




class shasta::mode3::GlobalPathGraphEdge {
public:
    uint64_t vertexId0;
    uint64_t vertexId1;
    MarkerGraphEdgePairInfo info;

    // The number of oriented reads for which the journey contains
    // a transition from vertexId0 to vertexId1.
    // This is less than or equal to info.common.
    uint64_t coverage = invalid<uint64_t>;
};



class shasta::mode3::GlobalPathGraph {
public:
    static void assemble(
        const Assembler&,
        uint64_t threadCount0,
        uint64_t threadCount1);
    static void loadAndAssemble(
        const Assembler&,
        const string& fileName,
        uint64_t threadCount0,
        uint64_t threadCount1);
private:
    GlobalPathGraph(const Assembler&);
    const Assembler& assembler;

    // Each vertex corresponds to a primary marker graph edge.
    // Store them here.
    // The index in this table is the vertexId.
    // The table is sorted by MarkerGraphEdgeId.
    // It cannot be named "vertices" because of name conflicts with the Boost graph
    // iteration macros.
    vector<GlobalPathGraphVertex> verticesVector;
    void createVertices();

    // Return the vertexId corresponding to a given MarkerGraphEdgeId, or
    // invalid<MarkerGraphEdgeId> if no such a vertex exists.
    // This uses a binary search in the verticesVector (via std::lower_bound).
    uint64_t getVertexId(MarkerGraphEdgeId) const;

    vector<GlobalPathGraphEdge> edges;
    void createEdges();

    // The connected components of the GlobalPathGraph.
    // Stored sorted by decreasing size, as measured by number of vertices.
    vector< shared_ptr<PrimaryGraph> > components;

    // Create connected components.
    // This only considers edges with corrected Jaccard at least equal to
    // minCorrectedJaccard, and only stores connected components with at
    // least minComponentSize vertices.
    void createComponents(
        double minCorrectedJaccard,
        uint64_t minComponentSize);

    // Local transitive reduction of each connected component.
    // Only edges with coverage up to maxCoverage are subject to flagging
    // as removed during transitive reduction.
    void localTransitiveReduction(
        uint64_t distance,
        uint64_t maxCoverage);

    // Write the entire PathGraph in graphviz format.
    void writeGraphviz() const;

    // Write each connected component in graphviz format.
    void writeComponentsGraphviz(
        const string& baseName,
        const GlobalPathGraphDisplayOptions&) const;

    void assembleComponent(
        uint64_t componentId,
        double maxLoss,
        uint64_t transitiveReductionDistance,
        uint64_t transitiveReductionMaxCoverage,
        uint64_t crossEdgesLowCoverageThreshold,
        uint64_t crossEdgesHighCoverageThreshold,
        uint64_t crossEdgesMinOffset,
        uint64_t threadCount0,
        uint64_t threadCount1);

public:
    static void searchForDetangling(
        const array<MarkerGraphEdgeId, 2>& in,
        const array<MarkerGraphEdgeId, 2>& out,
        uint64_t highCommonCountThreshold,
        uint64_t lowCommonCountThreshold,
        const Assembler&,
        array<array<vector<MarkerGraphEdgeId>, 2>, 2>&);

};


